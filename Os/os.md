

## 什么是操作系统？ 

> 我们平时用到的windows，macos系统，常常在小黑框出现的linux系统，又或者是手机里面的ios系统，都是操作系统！

那么到底从概念上来看到底什么是操作系统呢？

### 我们还是从生活的角度出发。

我们都知道，一台电脑的诞生。是从硬件开始的，在装完cpu，散热器，显卡，风扇之类的东西以后，你的机箱亮了！

亮了之后呢，我们插了个u盘，开始我们操作系统的安装！安装完成以后，我们又安装软件，然后用软件实现各种需求（聊天~摸鱼~）

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101134505177.png)

所以，我们可以看出来，既然是从u盘中下载下来的，说明操作系统的本质其实是软件！

### 操作系统的作用

操作系统其实更像是一个**承上启下**的桥梁。

- 它负责管理协调硬件，软件等计算机资源的工作
- 它为上层的应用软件，用户提供简单易用的服务
- 他是软件，不是硬件！

> 操作系统是控制和管理计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供用户和其他软件更方便的接口和环境，他是计算机系统最基本的系统软件

那么其实我们的任务管理器，就是给软件和硬件的管理，做了个可视化界面

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101135303427.png)

### 操作系统的功能和目标——系统资源的管理者

那么，操作系统作为一个承上启下的资源管理者，他又实现了哪些功能呢？

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101135724202.png)

比如，我们打卡一个qq软件，实际上就是打卡qq.exe的启动文件，那么找到这个启动文件就需要用到文件资源管理器

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101135909110.png)

这体现了操作系统的**文件管理**。

在点击qq.exe之后，程序开始运行，我们需要把程序相关数据，放入内存，这体现了操作系统的**存储器管理**。

打开qq以后，我们要视屏通话，需要摄像头，操作系统帮我们打开了，这体现了操作系统的**设备管理**。

### 操作系统的功能和目标——作为用户和计算机硬件之间的接口

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101140612665.png)

#### 什么是联机命令接口呢？

其实很简单，你打开cmd，用一个最简单的cd命令进入文件夹，就是一个联机命令接口。

#### 什么是脱机命令接口呢？

大家应该都见过.bat文件吧？.bat文件就是脱机命令接口，它是将很多联机命令接口整合到了一起，点击它一起运行！

#### 什么是程序接口呢？

他就是一些.dll文件，他是程序调用的东西，他能实现创建窗口等功能。用户只能间接调用它

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101141347139.png)

#### 什么是GUI？

他是一个图形用户界面。它无需复杂命令，只用拖拽点击方式，实现程序功能。比如你把文件拖进垃圾站里。而命令则对应是`rm -rf`

### 操作系统的功能和目标——最接近硬件的层次

刚刚提到操作系统是在裸机上安装的。它的目标很明确，就是对于硬件机器的扩展，将他改编成更加方便的，更加强大的机器。

我们通常把覆盖了软件的机器叫扩充机器，又称之为虚拟机。

> 类比成生活，硬件就是锤子，优秀的工匠就是使用锤子的人

## 操作系统的特征

### 并发

并发是指多个事件同一时间间隔上在宏观同时发生，但在微观上交替发生。

> 并行是两个或多个时间在同一时刻发生

比方现在有俩渣男。

第一个渣男喜欢和女一号女二号一起约会。**这是并行**

第二个渣男订好了时间，9-10点约女一，10-11约女二。从宏观来看，他同时进行了俩约会入伍，微观来看，某一时刻，他最多进行一个约会任务。**这是并发**

### 操作系统的特征——并发

操作系统的并发性指在计算机系统中同时运行着多个运行的程序。

如果你的cpu是单核的，那么它同一时刻只能执行一个程序，因此操作系统会负责协调多个程交替发生（宏观同时，围观交替 ）

但是如果 你的cpu是多核的，比如Intel的i3 i5 i7，这意味着，同一时刻是由多个程序可以**并行执行**的。但是，操作系统的并发性依然必不可少。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101145525273.png)

因为我们操作系统的时候，肯定有远超过cpu核数的进程数目的。

### 操作系统的特征——共享

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101145647921.png)

操作系统有两种资源共享的方式，一种是互斥共享；一种是同时共享

互斥共享是指某些资源是虽然能提供给多个线程使用，但是，**一个时间段只允许一个进程访问该资源。**

同时共享指的是，某些资源允许一个时间段，**多个进程“同时”对他们进行访问。**

> 这里的“同时”是宏观上的，围观可能是交替的

#### 生活实例

互斥共享：你在电脑上同时打开微信，qq，只有一个进程可以使用摄像头。

同时共享：用qq发送文件A，微信发送文件B。从宏观上来看，微信和qq同时在占用硬盘资源，读取文件。但是从微观上来看，两者是交替访问硬盘的。

### 操作系统的特征——并发和共享的关系

- 并发性：指计算机系统同时存在多个运行着的程序。
- 共享性：指系统内的资源可供内存中多个并发执行的程序共同使用。

从用qq发送文件A，微信发送文件B的例子来看：

1. 两个进程并发执行（并发性）
2. 需要共同访问硬盘资源（共享性）

>  因此，我们发现，并发和共享相互依存

### 操作系统的特征——虚拟

虚拟是指一个物理上的实体，变成若干逻辑上的对应物。物理实体是实际存在的，逻辑对应物是用户感知到的。

#### 生活案例

**案例一**：比如说我的电脑有4G的内存，我打开了需要4G内存的lol，还打开了qq，微信，实际上这些东西的内存超过4G了，但是他们还能运行。

> 这是虚拟存储技术，实际4G，用户看来远超4GB。这也是虚拟技术中的“空分复用技术”。

案例二：一个单核cpu可以打开多个程序。我们都知道，一个程序需要放入内存，并分配cpu才能执行。那为什么单核cpu可以执行那么多程序呢？

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221101151407378.png)

这里则用到了虚拟处理器技术。实际上有一个cpu，但用户看到了多个cpu在为自己服务。

> 这是虚拟技术中的“时分复用技术”，它将时间分成一个个时间片，交替利用单个cpu处理不同进程

### 操作系统的特征——异步

异步是指多道程序环境下，允许多个程序并发执行。但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度推进，这就是进程的异步性

其实简单理解，程序为什么会走走停停呢？其实就是因为太穷了！可分配的资源太有限了，进程需要一个资源的时候，另一个进程在使用这个资源，所以它需要停下来等待！

> 所以我们发现，只有系统拥有并发性，才有可能导致异步性！

### 重要考点

- 理解并发和并行的区别
- 并发和共享是互为存在条件的
- 没有**并发，共享**，就谈不上虚拟和异步。
- **并发和共享**是操作系统两 最基本的特征

因为共享的前提是，很多进程一起执行，去访问某个资源。



## 中断和异常

### 中断机制的诞生

在早期计算机里，只有一个程序执行完以后，另一个程序才能进行。因此，各个程序只能串行执行，系统利用率很低。

为了解决上述问题，人们发明了操作系统，引入中断机制，实现了多道程序并发执行。

> 本质：发生中断就意味着需要操作系统进行介入，开展管理工作

#### 那么操作系统又是怎么进行中断这一行为的呢？

首先，进程1会在**用户态**下执行，cpu会收到操作系统的计时部件发出的中断信号。它会切换成**核心态（核心态权限高，能中断）**，它将cpu的使用权限交给操作系统，操作系统内核负责中断信号进行处理。

操作系统之后就会告诉进程，进程1的时间片已经用完，换进程2运行

之后，操作系统会将cpu的使用权交还给用户进程，进城2就会继续执行。

等进程2执行一段时间以后，它想做io操作了，于是它发出系统调用（内中断信号），请求输出。于是，cpu就切换为核心态，对中断进行处理，进行io操作。（因为io操作只能核心态处理）

之后呢，操作系统就乖乖听从进程2的请求，调用打印机，进程2暂停运行，等待I/O操作。

之后呢，操作系统会把用户态还给进程3 。此时打印机是和进程3并行执行的。等打印机操作完成，它会像cpu发送中断信号。

cpu接收到信号之后，又会切换到**核心态**对中断进行处理了。 

#### 总结

1. 当中断发生，cpu立刻进入核心态
2. 中断发生以后，当前运行的进程暂停运行，并且由操作系统内核对中断进行处理
3. 对于不同的中断信号，会有不同的处理

> 发生了中断就意味着，需要操作系统进行介入，开展管理工作。但是这些管理工作（如进程切换，I/O设备）需要用到特权指令，因此，cpu需要从用户态转变成核心态才行。**而中断可以使CPU从用户态转化为核心态，使操作系统获得对计算机的控制权。有了中断**，程序才可以并发的执行。

注意：用户态——>核心态是通过中断实现的。**而中断是唯一的途径**

而 核心态——>用户态则是通过**执行一个特权指令**，将程序状态字PSW（0和1）的标志位设置为“用户态”。

### 中断的分类

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102130442726.png)

中断分为两类，分别是内中断和外中断。

内中断也叫异常，例外，陷入。异常我们大伙儿很熟悉，就是程序里面的异常如 i/0 这种，这种中断叫强迫中断。和此种软件中断相并列的还有硬件故障，他也是强迫中断。

和强迫中断对应的则是自愿中断——指令中断，这是通过指令实现的中断。

####  外中断处理过程

其实对于外中断的处理。cpu是这样做的：

1. 在每条指令完成以后，cpu都会检查是否有外部中断信号
2. 如果检测到有外部中断信号，那么就需要保护被终端进程的cpu环境（如程序状态字PSW,各种通用寄存器等）
3. 根据中断信号类型，转入相应中断处理程序，从用户态到核心态的改变
4. 恢复原来的进程的cpu环境，返回原进程继续向下执行

## 系统调用

#### 知识点回顾：

操作系统作为一个桥梁，需要向上提供简单易用的服务。主要包括，命令接口和程序接口。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102131205654.png)

我们今天要讲的系统调用，就是在程序接口中提到的。

> 系统调用是操作系统提供给程序员使用的接口，可以理解为一种可供应用程序调用的特殊函数。应用程序可以发出系统调用请求来获得操作系统的服务

### 什么是系统调用？有什么作用？

> 其实，存储分配，I/O操作，文件管理等，都是通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证用户的稳定性和安全性。防止用户进行非法操作。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102151028598.png)

像上面这些，设备管理，文件管理，进程控制，进程通信，内存管理的功能，都是需要**特权指令**才能完成。因此，系统调用的相关处理需要在**核心态**下进行。

### 系统调用和库函数的区别

刚刚提到的系统调用是操作系统为了服务于上层的函数。

那么它和java，c语言的库里面的函数又有有什么区别呢？

其实应用程序可以先调用语言的库函数，然后这些库函数，会再调用专门为了系统调用的函数。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102151704507.png)

> 注意，系统调用的相关处理在核心态上进行

不涉及系统调用的库函数：比如加减，取绝对值

涉及系统调用的库函数：比如创建新的文件

> 高级语言代码调用参数 ——> 用户态下汇编语言执行陷入指令 ——> 在核心态下，调用 相应服务程序 ——> 返回用户程序

#### 注意

1. 陷入指令是在用户态完成的，执行陷入指令之后，会立刻引发一个内中断，让cpu进入核心态
2. 发出系统调用请求是在用户态，而对于系统调用的处理是在核心态下进行的
3. 由于核心态可以执行特权指令和非特权指令，而陷入指令是唯一一个只能在用户态下执行，而不可在核心态下执行的指令

### 核心考点

1. 系统调用会让发生内中断，CPU从用户态进入核心态
2. 设备管理，文件管理，进程控制，进程通信，内存管理，这些凡是于资源有关的操作，会直接影响到其它进程的操作，一定会需要操作系统进行介入，也就是通过系统调用来实现。
3. 系统调用发生在用户态，而对系统调用的处理发生在核心态
4. 执行陷入指令会产生内中断，让 用户态进入核心态

## 进程

### 进程的定义

我们都知道，程序的本质，就是一个指令序列。

在早期的计算机里面，它只支持单道程序。

在一个程序运行的时候，他说，cpu是我的！内存是我的！I/O设备也是我的！

然后呢，他把程序段放在内存的低地址区域，把数据段放在高地址区域。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102161435819.png)

在引入多道程序技术之后，计算机就可以运行多个程序了。

这个时候，内存中就得放好多的程序段，好多的数据段！

此时，程序是并发的执行的，而操作系统的任务就是找到各个程序段，在内存的位置，找到对应的数据段。

**所以，为了让操作系统能更好的去管理各个程序，让他们能并发的执行。引入了我们的主角——进程！**

> 系统会为每个运行的程序配置一个数据结构，称为进程控制块（PCB），用来描述程序代码存放的位置

因此，PCB（Process Control Block），程序段，数据段，构成了进程的实体！



![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102162235592.png)

> 因此，我们平时所说的创建一个进程实际上是指，创建进程实体中的PCB,撤销进程实际上是撤销进程实体中的PCB

**PCB是进程存在的唯一标志！PCB是进程的管理者，它记录了进程的信息， 进程控制和管理，资源的分配，处理机相关信息**

对于进程，比较传统的定义有：

1. 进程是程序的一次执行过程
2. 进程是一个程序以及其数据在处理机上顺序执行所发生的活动。

> 讲的很多东西，都不是人话，总结下来就是，这些定义都在强调进程的一个特性——**动态性**

我们刚刚说了，程序段，数据段，构成了进程的实体。而进程实体是**静态**的。**严格来讲**，进程和进程实体不一样。进程是运行起来的进程实体，**它是动态的！！**

### 进程的组织

> 在一个系统中，通常会有上千个PCB，为了进行有效的管理，我们应该用适当的方式把PCB进行管理

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102163757943.png)

进程的组织方式有两种：链接方式和索引方式。

#### 链接方式

链接方式中有3种指针，指向进程的不同的状态。

- 执行指针指向正在执行的进程
- 就绪队列指针指向处于就绪态的进程（通常会有很多，优先级高的在前面）
- 阻塞队列指针指向处于阻塞态的进程。

#### 索引方式

链接的指向指的是队列。而索引的方式指的是索引。两者很类似。

唯一不同的是，索引表还会再指向不同的PCB

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102164315867.png)

### 进程的特征

- 动态性

  进程是程序的一次执行过程，是动态产生，变化，消亡的

- 并发性

  内存中有多个进程实体，各个进程并发执行

- 独立性

  进程是能独立运行，独立获得资源，接受调度的基本单位
  
- 异步性

  之前我们说过，两个进程争夺一个资源的时候，无法确定抢到速度的快慢，因此它们是按照各自独立，不可预知的速度向前推进的。

- 结构性

  每个进程都配置了一个PCB。结构上来看，都是PCB，程序段，数据段

### 重要考点

- 定义：进程是进程实体的运行过程，是系统进行资源调度和分配的基本单位
- PCB是进程存在的唯一标志，他是进程的管理者
- 程序本身的运行所需要的数据在程序段和数据段
- 动态性：进程最基本特征；独立性：进程是进行资源分配，调度的基本单位

### 进程的状态和切换

#### 进程的状态——三种基本状态

分为运行态，就绪态，阻塞态。

- 运行态占有CPU，并在CPU上面运行。
- 就绪态具备了运行条件，但是没有空闲CPU，因此在等待（完事具备，只欠CPU）
- 阻塞态因为在等待某个时间暂时不能运行

#### 进程的状态——另外两种状态

我们都知道，一个程序运行的时候，会在内存中创建PCB，程序段，和数据段。

> 在这个创建的过程，我们就叫他创建态

在进程运行结束（或者遇到一些异常导致进程无法继续进行下去，比如i/0），需要撤销进程，比如回收内存区域，撤销I/O设备的权限

> 在这个撤销的过程，我们就叫他终止态

因此，进程有5种状态

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102165903893.png)

### 进程的切换

我们通过一张图，来总体的看一下各个状态的转换。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102170753684.png)

在创建态完成之后，系统已经做好了准备工作。比如PCB的创建

随机它进入了就绪态，就绪态他拥有了除了处理机以外的其他权限。

随后由于上一个进程的时间片到了，进程被CPU调度，它拥有了处理机的权限！

于是，她就想用系统调用的方式，进入核心态，获得打印机的资源。于是，他就进入了漫长的等待，也就是阻塞态。阻塞状态下，他失去了处理机和其他资源的权限。

等完了以后，申请的资源被重新分配回来了，它又回到了就绪态，此时它又拥有了除了处理机以外的其他权限。

然后它被调度，进入运行态。

程序运行结束了，或者遇到异常了，它进入终止态，从cpu中回收资源，撤销PCB

> 我们发现，从运行态到阻塞态，是主动申请资源的过程，是主动的
>
> 而从阻塞态到就绪态，是等待资源响应的过程，是被动的

### 进程的控制

#### 基本概念

> 进程控制简单理解，就是实现刚刚说的5种进程状态的转换

#### 如何实现？

我们知道，操作系统会将很多PCB挂到相应状态的队列当中。

-  创建态——>就绪态

  需要修改PCB内容进入就绪队列。

- 就绪态——>运行态

  需要恢复程序运行环境（之前可能没执行完，没到终止态），修改PCB内容和相应队列

- 运行态——>就绪态

  这是进程切换了，比如进程3切换到进程1，需要修改PCB内容，将他放进阻塞队列

- 阻塞态——>就绪态

  需要修改PCB内容，将他放进就绪队列。如果等待资源，还需要给进程分配系统资源

- 运行态——>终止态

  回收资源，撤销PCB

思考一个问题，如果说一个进程将它从一个队列改为另一个队列，但是系统没有改PCB里面的状态标志（PCB的内容）。

**这种情况很危险，有可能导致系统错误！！**

为了防止这个问题，采用了**原语**

### 什么是原语？

原语的特点就是不允许中断，一气喝成。

> 学过多线程的同学也知道，这其实是原子操作

那原语的本质又是啥呢？

原语采用“开中断”，“关中断”指令实现。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221102220316649.png)

>  在“开中断”，“关中断”之前的操作，不会被外部中断信号打断。

既然它这么牛，其实我们也可以想到，这是操作系统在核心态中执行的特权指令。

既然说到特权指令，那我们不得不再复习一下操作系统的内核了。

> 操作系统内核：时钟管理，中断管理，原语，对系统资源的管理（进程管理，存储器管理，设备管理）

#### 进程相关的原语

本质：进程控制会导致进程状态的转换。无论哪个原语，要做的无非3件事情：

1.更新PCB信息（如修改进程状态标志，将运行环境保存到PCB，从PCB中恢复运行环境）

- 所有的进程控制原语就一定会修改进程状态标识
- 剥夺当前运行的CPU之前，就一定得保存其运行环境
- 某进程开始运行前，需要恢复运行期环境

2.将PCB插入合适队列

3.分配/回收资源

### 进程通信

#### 什么是进程通信？

> 顾名思义，其实进程通信就是指进程之间的信息交换

进程是系统分配资源的单位，因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

> 但是进程之间的信息交换又是必须实现的，为了保障进程间的通信，操作系统提供了一些方法

#### 进程通信——共享存储

我们可以再内存中设置一个共享空间。供两个进程来访问。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221103112008878.png)

这两个进程对共享空间的访问必须是互斥的。

#### 进程通信——管道通信

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221103112258684.png)

> 管道是用于连续读写进程的一个共享文件，其实就是再内存中开辟一个大小固定的缓冲区

但由于上图，我们发现，管道只能采用半双工通信，**某一时间段**只能实现单向的传输。但如果实现双向同时通信，则需要设置两个管道。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221103112531258.png)

各个进程对于管道的访问也是需要互斥的进行的

管道通信的具体流程：进程1 往管道内部写入数据，当管道写满的时候，写进程的write（）系统调用将会被阻塞，等待读进程将数据取走。当都进程将数据全部取走以后，此时读进程的read（）系统调用将会被阻塞。

> 注意：如果没有写满，不允许读。如果没有读完，不允许写；
>
> 并且数据一旦读出，就从管道内被抛弃了。这意味着读进程最多只能有一个，否则会有读错的情况

#### 进程通信——消息传递

进程间的数据交换以**格式化的消息**，（Message）为单位。进程通过操作系统提供的**“发送消息/接受消息**”两个原语进行数据的交换。

> 一个Message包括消息头和消息体。消息头里面包括进程ID，接受进程id，信息类型，消息长度等格式化信息。

而消息传递有分为两种方式——直接通信，间接通信。

- 直接通信就是将Message挂载到接受消息的进程当中，形成一个队列。

- 间接通信就是在俩进程之间设置一个信箱。从中寄出或者取走信息。（有点像公共存储区域）

### 重要考点

1. 共享存储需要互斥的访问空间
2. 一个管道只能实现半双工通信（单向）
3. 管道通信写满不写，读空不读；没写满不读，没读空不写
4. 消息传递的两种方式

## 线程，多线程模型

### 什么是线程？为什么要引入线程？

> 有的程序需要同时做很多事情，而传统的进程只能串行执行一些程序。为此，我们需要引入线程增加并发度

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221103193211726.png)

CPU会根据一些算法，轮流的为一些线程服务。

比如我们打开QQ这一个进程，那么QQ视频聊天和传送文件就分别是两个线程。

> 在引入线程之后，线程成为了程序执行流的最小单位。线程是轻量级进程

**线程是一个基本CPU的执行单元，也是程序执行流的最小单位**

引入线程之后，不仅各个进程之间可以并发执行，各个线程之间也是可以并发执行的。着更加提升了系统的并发度。

在线程取代进程成为基本CPU执行单位以后，进程就像是升官了一样，它就开始管理进程了，他**是资源分配的基本单位**

### 线程的属性

1. 线程是处理机调度的基本单位
2. 多CPU处理中，各个线程可占用不同的CPU，毕竟我们现在的cpu不止1核
3. 每个线程都有一个线程id，线程控制块（TCB）类似PCB
4. 线程也有就绪，阻塞，运行三种基本状态
5. 线程几乎不拥有系统资源，系统资源都是在进程那里，由进程分配
6. 其实，同一进程下面的很多线程可以共享进程的资源。有点像父亲的钱，由儿子们共享
7. 由于之前提到过，线程之间通信有一个共享的内存地址空间，因此，同一进程中的线程间通信甚至无需系统干预
8. 同一进程中的线程切换，不会引起进程切换
9. 切换进程内的线程，开销小，而进程开销大

### 线程的实现方式

#### 用户级线程

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221104131159769.png)

用户线程由应用程序通过线程库实现。所有线程管理工作应该都是由应用程序负责。

用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

> 可以这样理解，用户级线程就是从用户视角能看到的线程

#### 内核级线程

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221104131631304.png)

内核级线程的管理工作由操作系统内核完成。

线程调度，切换都是由内核负责，因此内核级线程的切换必须要在**核心态**下才能完成。

> 可以这样理解，内核级线程就是从操作系统内核视角能看到的线程

#### 用户级线程和内核级线程

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221104132327675.png)

例如：这个模型里，用户看到了三个进程，对应两个内核级线程。即使这个cpu是4核的，由于只有俩内核级线程。最多也只有两个用户线程并行执行。

> 操作系统只看的见内核级线程，因此只有内核级线程才是处理机分配的单位

### 多线程模型

#### 多对一模型

多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105141217773.png)

优点：用户级线程切换方便，无需在核心态下完成，线程管理成本开销小，效率高

缺点：当一个用户级线程阻塞之后，整个进程会被阻塞，并发度不高。

#### 一对一模型

一个用户级线程映射一个内核级线程。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105141814638.png)

优点：一个用户级线程被阻塞后，其它线程不会被影响。

缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统完成，需要切换到核心态。线程管理成本高。

#### 多对多模型

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105142108559.png)

克服了多对一模型并发度不高的缺点，又克服一对一模型一个用户进程占用太多内核级线程，开销太大的缺点。

#### 重要考点

1. 线程是处理机调度的单位，进程是资源分配的单位
2. 从操作系统来看，只有内核级线程才是处理机分配的单位
3. 多对一模型的缺点：一个线程阻塞容易导致整个进程阻塞。

## 处理机调度的概念，层次

#### 基本概念

> 一堆很麻烦的任务要处理，但是处理的人，资源有限，无法同时处理。所以需要某种规则来决定处理的顺序。这就是调度要解决的问题。

在计算机中，由于进程的数量大于处理机器的个数，因此同样不能并行处理各个进程。

因此我们需要一个算法，选择一个进程，将处理机资源分配给他。

#### 调度的三个层次——高级调度

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105143428618.png)

现在外存中有很多任务，我们放入后备队列当中。

高级调度（作业）：按照一定的原则，从外存中取出一个或者多个作业，给他们分配内存等必要资源，并且建立相应的进程（PCB）,让他们获得竞争处理机的权利。

> 高级调度是外存和内存之间的调度。每个作业调入一次，调出一次。作业调入的时候会建立相应的PCB，调出才撤销PCB。高级调度主要指调入问题

#### 调度的三个层次——中级调度

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105144017256.png)

引入虚拟内存技术之后。可以将暂时不能运行的进程调至外存等待。等他重新具备运行条件以后，再重新调入内存。

> 暂时放在外存中等待的状态叫挂起状态。PCB并不会被一起调入到外村，而是会常驻内存。操作系统会通过内存中的PCB来保持对各个进程的监控，管理。被挂起的进程PCB会被放到挂起队列中。

中级调度（内存调度），就是决定哪个处于挂起状态的进程重新调入内存。

一个进程可能被多次调用，调出。因此中级调度发生的频率比高级调度高。

#### 调度的三个层次——低级调度

低级调度（进程调度），主要任务就是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给他。

> 这是最基本的一种调度

进程调度的频率很高，一般几十毫秒一次。

#### 三层调度联系，对比

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105145245518.png)

## 进程调度的时机，切换于过程调度方式

### 进程调度的时机

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程分配给处理机。

**不能进行进程调度与切换的情况**

- 处理中断的时候
- 原子操作
- 进程在操作系统**内核程序临界区**中

> 临界资源：一个时间段只允许一个进程使用的资源，各进程需要互斥的访问
>
> 临界区：访问临界资源的那段代码
>
> 内核程序临界区：访问某种内核数据结构的代码，由于访问的时候，是上锁的，如果在这个时候释放，还没有解锁，就会影响到操作系统内核其他的管理工作

### 进程调度的方式

#### 非剥夺调度方式，又称非抢占方式

只允许进程主动放弃处理机。在运行该过程中，即使由更加紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或者主动要求进入阻塞态

#### 剥夺调度方式，又称抢占方式

当一个进程在处理机上执行，如果有一个更加紧迫的进程需要使用处理机，那么就会立刻暂停正在执行的进程，将处理机分配给更重要紧迫的进程

### 进程切换与过程

> 进程切花主要完成了：1.对原来运行进程的数据保存。2.对新的进程的数据恢复
>
> 其实也就是从PCB中保存，拿出数据

注意：进程的切换是有代价的。如果过于频繁的进行切换，调度，必然会使整个系统的效率降低。让系统大部分时间花在了进程切换上，而真正用于执行进程的时间在减少。

## 调度算法的评价指标

#### CPU利用率

利用率 = 忙碌时间/总时间

#### 系统吞吐量

单位时间内完成的作业数量

系统吞吐量 = 总共完成的作业数目 / 总共花费时间

#### 周转时间

周转时间 = 作业完成时间 - 作业提交时间

平均周转时间 = 各作业周转时间的和 / 作业数

带权周转时间 = 周转时间 / 作业实际运行时间。 

> 带权周转时间 越小，满意度越高

平均带权周转时间 = 各作业带权周转时间之和 / 作业数

## 调度算法

### 先来先服务（FCFS）

> FCFS: first come first serve

算法思想：主要从公平的角度去考虑

**算法规则**：按照作业/进程先后到达顺序进行服务。

用于作业/进程调度：用于作业调度，考虑的是哪个进程先到达后备队列；用于进程调度，考虑的是哪个进程先到达就绪队列。

**是否可抢占**？ 非抢占式算法

#### 例题

###### 各进程到达就绪队列的时间，需要运行的时间如下图。使用FCFS调度算法，计算各个进程的等待时间。平均等待时间。周转时间，平均周转时间，带权周转时间，平均带权周转时间

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105161828459.png)

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105161926385.png)

但是我们看P3的带权周转时间

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105162039237.png)

由于带权周转时间很大，所以它的周转时间相对较大。所以对运行时间短的进程很不利。

**是否会导致饥饿**？不会

### 短作业优先（SJF）

> 短作业优先（Shortest Job First）

**算法思想：**追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间。

**算法规则**：最短的作业/进程优先得到服务（所谓最短，指要求服务的时间最短）

**用于作业/进程调度**：这个算法既可以用作作业调度，又可以用作进程调度。用作进程调度的时候被称为（短进程优先（SPF,Shortest Process First）算法）

**是否可抢占**？SJF和SPF是非抢占式算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN,Shortest Remaining Time Next）

#### 例题

###### 各进程到达就绪队列的时间，需要运行的时间如下图。使用非抢占式的短进程优先调度算法(SPF)，计算各个进程的等待时间。平均等待时间。周转时间，平均周转时间，带权周转时间，平均带权周转时间

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105161828459.png)

![SD](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105172929452.png)

#### 例题

###### 各进程到达就绪队列的时间，需要运行的时间如下图。使用抢占式的短进程优先调度算法(SPF)，计算各个进程的等待时间。平均等待时间。周转时间，平均周转时间，带权周转时间，平均带权周转时间

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105161828459.png)

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105184738468.png)

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105185446312.png)

> 所有进程几乎同时到达的时候，采用SJF调度算法的平均等待时间，平均周转时间最少。

虽然严格来说。SJF的平均等待时间，平均周转时间并不一定最少，但是相比于其他算法如（FCFS）可以获得较少的平均等待时间，周转时间。

**优点：**“最短的”平均等待时间，平均周转时间

**缺点：**不公平，对于短作业有利，长作业不利。可能产生**饥饿现象**。

**是否导致饥饿？**会，如果有源源不断地短作业/进程到来，会使长作业/长进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，就会“饿死”。

### 高相应比优先（HRRN）

**算法思想：**综合考虑作业/进程的等待时间和要求服务的时间

**算法规则：**每次调度时，先计算作业/进程的相应比，选择相应比最高的作业/进程进行服务。

>  相应比 = （等待时间 + 要求服务时间）/ 要求服务时间      >=1

**用于作业/进程调度**：既可用于作业调度，也可用于进程调度

**是否可抢占？**非抢占式的算法。只有当前的作业/进程主动放弃处理机的时候，才需要调度，才需要计算相应比。

#### 例题

###### 各进程到达就绪队列的时间，需要运行的时间如下图。使用高响应比的短进程优先调度算法(SPF)，计算各个进程的等待时间。平均等待时间。周转时间，平均周转时间，带权周转时间，平均带权周转时间

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105161828459.png)

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105192420010.png)

等待时间相同的时候，要求服务时间短的优先。

对于长作业，等待时间越长，响应比会越大。避免了长作业饥饿的问题。

**是否会导致饥饿**？不会

## 调度算法（二）

### 时间片轮转调度算法

**算法思想：**公平，轮流的为各个进程服务，让每个进程在一定时间内都可以得到响应。

**算法规则：**按照各个进程到达就绪队列的顺序。轮流让各个进程执行一个时间片（如100ms）,若一个进程未在以恶搞时间片内执行完，则剥夺处理饥饿，将进程放在就绪队列队尾重新排队































**用于作业/进程调度：**用于进程调度（只有作业放入内存建立了相关的进程后，才能被分配处理机时间片）

**是否可抢占**？若进程未在时间片内运行完，将会被剥夺处理机使用权。因此该算法属于抢占式算法。由时钟装置发出时钟中断来通知cpu时间已到。

#### 例题

###### 各进程到达就绪队列时间，需要的运行时间如下图。使用时间片轮转调度算法，分析时间片大小分别为2，5时的进程运行情况。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105200023878.png)

```
p1

0 时刻：

	就绪队列：P1（5）

2时刻：

	就绪队列：P2(4) -> P1（3）

4时刻：

	就绪队列：P1(3) ->P3(1) -> P2(2)
	
5时刻：

	就绪队列：P3(1) -> P2(2) -> P4(6)
	
6时刻;

	就绪队列：P3(1) -> P2(2) -> P4(6) -> P1(1)
	
7时刻：

	就绪队列：P2（2）-> P4(6) -> P1(1)
	
8时刻：

	就绪队列：P4(6) -> P1(1) -> P2(1)
	
10时刻：

	就绪队列：P1(1) -> P2(1) -> P4（4）
	
11时刻

	就绪队列：P2(1) ->P4(4)

12时刻：

	就绪队列：P4(4)
	
14时刻：

	就绪队列：P4(2)
	
16时刻：

	就绪队列：
	
```



## 进程同步与进程互斥

### 什么是进程同步？

> 知识点回顾：由于进程具有**异步性**的特征。异步性是指各并发执行的进程以各自独立的，不可预知的速度向前推进。

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105201553919.png)

读进程和写进程并发执行，由于并发必然导致异步性。因此，读数据，写数据两个操作先后顺序不确定。而实际应用中，又必须按照“写数据——>读数据”顺序来执行。

> 同步也叫直接制约问题。它是指为了完成某种任务而建立两个或者多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就来源于它们之间的互相合作

### 什么是进程互斥？

进程的并发需要共享的支持各个并发执行的进程不可避免消炎药共享一些系统资源（比如内存，I/O设备）

我们把一个时间段只允许一个进程使用的资源叫临界资源。很多物理设备比如摄像头打印机都属于临界资源。

对于临界资源的访问，我们在逻辑上分为如下四个部分：

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221105202353422.png)**

进入区和退出区可以理解为上锁和解锁。临界区是在访问临界资源。剩余区做其他处理。

> 注意点：
>
> ​	临界区是进程中访问临界资源的代码
>
> ​	进入区和退出区是负责实现互斥的代码
>
> ​	临界区也可称为**临界段**

为了实现对临界资源的互斥访问，同时保证系统的整体性能，应该遵循以下原则：

1. 空闲让进。临界区空闲，可以允许一个请求进入临界区的进程立刻进入临界区
2. 忙则等待。当已有线程进入临界区。其他试图进入的进程必须等待
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。
4. 让权等待。当进程不能进入临界区，应该立刻释放处理机，防止进程忙等待。

## 进程互斥的软件实现方法

### 单标志法

**算法思想：**两个进程在访问完临界区后，会把临界区的权限转交给另一个进程。也就是说，每个进程进入临界区的权限只能由另一个进程赋予。

```
int turn = 0 

P0进程：					P1进程：
while(turn != 0);		  while(turn != 1):
critical section;		  critical section;
turn = 1;				  turn = 0;
remainer section;		  remainer section;
```

由于一开始turn = 0 .因此P0进程的while循环不满足，所以它就开始进行对临界资源的访问。之后修改为1后，P1进程也不再被whille一直卡住，也开始对临界资源的访问。

> turn 值的修改其实就是退出，并且将权限给p1.
>
> 这个方法实现了互斥。

但是这个算法的主要问题是违背了空闲让进原则。

因为如果P0进程不访问临界资源，那么P1就一直不会访问。而此时P1是空闲的。

### 双标志先检查法

**算法思想：**设置一个布尔型数组flag[],数组各个元素用来标记各进程想进入临界区的意愿。

```
boolean flag[2];
flag[0] = false;
flag[1] = false;

P0进程：						p1进程：
while(flag[1]);				  while(flag[0]);
flag[0]= true;				  flag[1] = true;
critical section;			  critical section;
flag[0] = false;			  flag[1] = false;
remainer section;			  remainer section;
```

每个进程只需要管自己的意愿通过管自己的意愿即可（改变flag值）。

其他进程需要判断其他进程的意愿。如果其他进程有这个意愿，就不能再进去。

但这个算法的问题是如果这个时候并发执行，按照

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221106131742053.png)

的顺序执行，P0和P1将会同时访问临界区。

### 双标志后检查法

跟前一个算法相比，就是先上锁，后检查

```
boolean flag[2];
flag[0] = false;
flag[1] = false;

P0进程：						p1进程：
flag[0]= true;				  flag[1] = true;
while(flag[1]);				  while(flag[0]);					critical section;			  critical section;
flag[0] = false;			  flag[1] = false;
remainer section;			  remainer section;
```

若按照

![](https://nika-picbed.oss-cn-hangzhou.aliyuncs.com/typoraimage-20221106132221521.png)

的方法执行，会导致P0和P1将都无法进入临界区。

>  双标志后检查法解决了忙则等待原则，但是，违背了“空闲让进”和"有限等待"原则，会因各进程都长期无法访问临界资源产生饥饿现象。

### Peterson算法

**算法思想：**双标志后检查法中，两个进程都想争着进入临界区，但是谁也不让谁，导致最后谁都无法进入临界区。于是Peterson想到一种方法，如果双方都争着进入临界区，其实可以尝试孔融让梨，主动让对方先进入临界区。

```
bool flag[2];
int turn = 0;
P0进程：
flag[0] = true;
turn = 1;
while(flah[1] && turn == 1);
critical section;
flag[0] = false;
remainer section;

P1进程：
flag[1] = true;
turn = 0;
while(flag[0] && turn == 0);
critical section;
flag[1] = false;
remainder section;
```

主要问题：不遵循让权等待原则，会发生忙等。

## 进程互斥的硬件实现算法

### 中断屏蔽方法

利用开/关中断指令实现。

> 与原语的实现思想相同，即在某进程开始访问临界区到访问临界区到结束访问为止，都不允许被中断，也就不能发生进程切换

```
***
关中断；
临界区；
开中断；
***
```

优点：简洁高效

缺点：不适用于多处理机。只适用于操作系统内核进程，不适用于用户进程。

### TestAndSet指令

简称TS指令，也有地方称TSL指令（TestAndSetLock），tsl指令是用**硬件实现**的。执行过程不允许被中断，只能一气喝成。

### Swap指令





























## 信号量机制

